<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘波的学习记录</title>
    <description></description>
    <link>http://localhost:4001/</link>
    <atom:link href="http://localhost:4001/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 19 Jul 2021 18:30:01 +0800</pubDate>
    <lastBuildDate>Mon, 19 Jul 2021 18:30:01 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Docker基础</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#docker常用命令&quot; id=&quot;markdown-toc-docker常用命令&quot;&gt;Docker常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker常用命令&quot;&gt;Docker常用命令&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    仅创建镜像
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker create&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    运行（不存在将创建镜像）
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run -d -it -p 8181:8181 --name onos gwsdn/onos:2.6.0
 -d deamon后台，--rm一次性容器，运行结束后删除
 -i 始终保持交互状态
 -t 终端
 -v 映射文件或目录，例如 -v /opt/conf/nginx.conf:/etc/xx.conf，注意宿主机地址不是‘/’或‘~/’开头，则是Volume机制
 -p 端口映射，默认是tcp端口  -p 80:8080/tcp，udp写为 -p 8181:8181/udp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Volume机制参考这里&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 19 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/19/docker-base/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/19/docker-base/</guid>
        
        <category>docker</category>
        
        
        <category>后端</category>
        
      </item>
    
      <item>
        <title>ElementUI表单使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#1基本使用&quot; id=&quot;markdown-toc-1基本使用&quot;&gt;1.基本使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
最近业务中一个比较复杂表单，使用的是ElementUI，记录下表单的使用和遇到的问题

&lt;h2 id=&quot;1基本使用&quot;&gt;1.基本使用&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;el-form&amp;gt;
    &amp;lt;el-form-item&amp;gt;
    &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
在el-form标签内部可以嵌套其他标签
</description>
        <pubDate>Wed, 14 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/14/web-vue-elui-form/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/14/web-vue-elui-form/</guid>
        
        <category>vue</category>
        
        <category>elementui</category>
        
        
        <category>Web</category>
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>数字签名</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#概念&quot; id=&quot;markdown-toc-概念&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
数字签名又名公钥数字签名，基于非对称加密算法和数字摘要算法，具有三大特性：可认证性(authentication)、不可抵赖性(non-repudiation)和完整性(integrity)。

首先我们考虑一个场景，客户端B在访问一个域名服务器S时要解决几个问题
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;保证数据的安全，不被窃听&lt;/li&gt;
    &lt;li&gt;保证数据的完整，不被篡改&lt;/li&gt;
    &lt;li&gt;保证服务器是合法的，可认证的&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

其中最主要的是保证服务器的合法性，其他的都可以在确保服务器合法后通过协商密钥加密传输数据来解决，而保证服务器合法性的根本是证书，证书的基础就是数字签名。

当然证书是验证证书持有者的合法性，所以不仅能验证服务器也能验证客户端，例如：银行的U盾用于验证客户端的合法性。

数字签名的核心还是使用的是非对称加密算法的私钥对需要签名的数据进行加密处理。
</description>
        <pubDate>Wed, 14 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/14/criptogram-digital/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/14/criptogram-digital/</guid>
        
        <category>digital</category>
        
        
        <category>加密算法</category>
        
      </item>
    
      <item>
        <title>常见加密算法</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#对称加密算法&quot; id=&quot;markdown-toc-对称加密算法&quot;&gt;对称加密算法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#des&quot; id=&quot;markdown-toc-des&quot;&gt;DES&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
在网络通信中，信息加密是最基本的信息安全策略

&lt;h2 id=&quot;对称加密算法&quot;&gt;对称加密算法&lt;/h2&gt;
其特点是加密和解密使用相同的密钥

&lt;h3 id=&quot;des&quot;&gt;DES&lt;/h3&gt;
DES : Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。

有个升级版本DES3，相当于进行3次数据加密。其安全性能不高，在我们的业务中很少使用。
</description>
        <pubDate>Mon, 12 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/12/criptogram/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/12/criptogram/</guid>
        
        
        <category>加密算法</category>
        
      </item>
    
      <item>
        <title>Juni和EasyMock的使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
自动化测试工具

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;a href=&quot;https://blog.csdn.net/qq_41357569/article/details/85089818&quot;&gt;Juni和EasyMock配合使用&lt;/a&gt;
</description>
        <pubDate>Sat, 10 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/10/test-tool/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/10/test-tool/</guid>
        
        <category>JUnit</category>
        
        <category>EasyMock</category>
        
        <category>Maven</category>
        
        
        <category>test</category>
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>jemalloc介绍</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jemalloc基本信息&quot; id=&quot;markdown-toc-jemalloc基本信息&quot;&gt;jemalloc基本信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jemalloc基本信息&quot;&gt;jemalloc基本信息&lt;/h2&gt;

在学习Netty时，发现buffer引入缓冲池，其借用了jemalloc的思想；jemalloc在android5.1开始，成为libc默认的heap管理器。在这里搜索下jemalloc相关资料，以作记录。

jemalloc使用一系列算法保证程序在申请和释放内存的高效稳定，主要有以下几个特点：

&lt;ol&gt;
  &lt;li&gt;
    线程默认都有自己的私有缓存空间tcache，线程中分配内存都走这里，若未分配成功再走其他流程，线程内部的缓存空间中申请内存可以不加锁。
  &lt;/li&gt;
  &lt;li&gt;
    内存区重新规划，使用不同大小的分配单元
  &lt;/li&gt;
  &lt;li&gt;
    内存释放时，小内存合并为大内存，并判断是否需要缓存以供后续使用
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 09 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/09/jemalloc-use/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/09/jemalloc-use/</guid>
        
        <category>netty</category>
        
        
        <category>c/c++</category>
        
        <category>优化</category>
        
      </item>
    
      <item>
        <title>Netty框架</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
在讨论Netty之前需要了解下我们处理网络请求的方案

&lt;ol&gt;
  &lt;li&gt;
    BIO
同步阻塞，服务器调用accept阻塞等待请求，当请求到来时创建线程处理，主线程继续等待请求。
  &lt;/li&gt;
  &lt;li&gt;
    NIO
异步非阻塞，ServerSocketChannel非阻塞模式，使用selector轮询各类事件。
  &lt;/li&gt;
  &lt;li&gt;
    AIO
只需要关心buffer的读写事件
  &lt;/li&gt;
&lt;/ol&gt;

上述方案使用原生API直接开发，流程比较繁琐，性能不好，并且容易出错，使用Netty可以简化流程，Netty中使用Handler串行执行，结构层次分明，逻辑清晰，并且一个客户端只注册在一个线程上，避免部分业务中出现并发问题。
</description>
        <pubDate>Thu, 08 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/08/netty-use/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/08/netty-use/</guid>
        
        <category>netty</category>
        
        <category>socket</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java线程相关</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#锁&quot; id=&quot;markdown-toc-锁&quot;&gt;锁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;锁&quot;&gt;锁&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    偏向锁/轻量级锁/重量级锁
是指synchronized锁状态，描述在对象头部Mark Word（可以使用库jol-core，ClassLayout.parseInstance()方法查看）
  &lt;/li&gt;
  &lt;li&gt;
    可重入锁/非可重入锁
可重入锁代表ReentrantLock，reentrant意思是‘再次进入’
  &lt;/li&gt;
  &lt;li&gt;
    共享锁/独占锁
ReadWritLock
  &lt;/li&gt;
  &lt;li&gt;
    公平锁/非公平锁
synchronized 是非公平锁，ReentrantLock通过带参构造公平锁
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 02 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/02/java-thread/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/02/java-thread/</guid>
        
        <category>thread</category>
        
        <category>threadlock</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>数据库基础</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
mysql常用基本指令
&lt;a href=&quot;https://blog.csdn.net/weixin_42368489/article/details/82813893&quot;&gt;https://blog.csdn.net/weixin_42368489/article/details/82813893&lt;/a&gt;

服务器相关资料
&lt;a href=&quot;https://www.pomit.cn/index.html&quot;&gt;https://www.pomit.cn/index.html&lt;/a&gt;

mysql与postgreSql比较
&lt;a href=&quot;https://www.biaodianfu.com/mysql-vs-postgresql.html&quot;&gt;https://www.biaodianfu.com/mysql-vs-postgresql.html&lt;/a&gt;

数据库的博客
&lt;a href=&quot;https://tonydong.blog.csdn.net&quot;&gt;https://tonydong.blog.csdn.net&lt;/a&gt;
</description>
        <pubDate>Fri, 02 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/02/db-base/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/02/db-base/</guid>
        
        <category>Db基础</category>
        
        
        <category>Database</category>
        
      </item>
    
      <item>
        <title>Bazel构建工具</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bazel安装&quot; id=&quot;markdown-toc-bazel安装&quot;&gt;Bazel安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
Bazel是Google开源的构建工具，原生支持java、C++的编译，开源社区也有支持其他语言的编译的rule。本文结合了自身实践过程来学习bazel。

&lt;h2 id=&quot;bazel安装&quot;&gt;Bazel安装&lt;/h2&gt;
bazelisk 是bazel的版本管理工具，不同版本的onos使用了不同版本的bazel，因此我们在编译onos的时候bazelisk会自动下载对应版本的bazel进行编译。

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/bazelbuild/bazelisk/releases/download/v1.4.0/bazelisk-linux-amd64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 01 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/01/build-bazel/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/01/build-bazel/</guid>
        
        <category>Bazel</category>
        
        <category>Onos</category>
        
        
        <category>Build</category>
        
      </item>
    
  </channel>
</rss>
