<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘波的学习记录</title>
    <description></description>
    <link>http://localhost:4001/</link>
    <atom:link href="http://localhost:4001/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 09 Nov 2021 16:06:37 +0800</pubDate>
    <lastBuildDate>Tue, 09 Nov 2021 16:06:37 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>记录ONOS自动添加的swagger文档中文乱码问题</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#问题&quot; id=&quot;markdown-toc-问题&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

在使用onos的doc时，添加中文的注释会在swagger页面显示乱码，原因是自动生成的swagger配置文件中写入了错误编码格式的字符。
&lt;img src=&quot;/assets/blog-img/build-onos-swagger-1-1.png&quot; alt=&quot;img&quot; /&gt;
</description>
        <pubDate>Tue, 09 Nov 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/11/09/onos-swagger/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/11/09/onos-swagger/</guid>
        
        <category>bazel</category>
        
        <category>onos</category>
        
        
        <category>build</category>
        
      </item>
    
      <item>
        <title>JVM内存模型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#常见的jvm&quot; id=&quot;markdown-toc-常见的jvm&quot;&gt;常见的JVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常见的jvm&quot;&gt;常见的JVM&lt;/h2&gt;

PC上的JVM实现版本主要有三类

Oracle HotSpot, Oracle JRockit, IBM JVM

移动平台Android的Dalvik/ART

我们最为关心的是JVM的内存模型，关系到业务运行的稳定性。
以下基于Hotspot虚拟机
</description>
        <pubDate>Fri, 01 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/10/01/java-memery/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/10/01/java-memery/</guid>
        
        <category>jvm</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Docker基础</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#docker常用命令&quot; id=&quot;markdown-toc-docker常用命令&quot;&gt;Docker常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker常用命令&quot;&gt;Docker常用命令&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    仅创建镜像
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker create&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    运行（不存在将创建镜像）
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run -d -it -p 8181:8181 --name onos gwsdn/onos:2.6.0
 -d deamon后台，--rm一次性容器，运行结束后删除
 -i 始终保持交互状态
 -t 终端
 -v 映射文件或目录，例如 -v /opt/conf/nginx.conf:/etc/xx.conf，注意宿主机地址不是‘/’或‘~/’开头，则是Volume机制
 -p 端口映射，默认是tcp端口  -p 80:8080/tcp，udp写为 -p 8181:8181/udp
 --net 映射网络 例如：host
 --ip 自定义网络设置自定义ip 例如：--ip 172.100.0.2
 --restart=always 总是保持启动，当docker启动时自动启动该容器，其他参数：
     no 不重启
     on-failure 退出状态非0时重启 加':n'，表示最多重启n次
     unless-stopped 非主动停止时重启
 --privileged=true 真实的root权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Volume机制参考这里&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 19 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/19/docker-base/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/19/docker-base/</guid>
        
        <category>docker</category>
        
        
        <category>后端</category>
        
      </item>
    
      <item>
        <title>ElementUI表单使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#1基本使用&quot; id=&quot;markdown-toc-1基本使用&quot;&gt;1.基本使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
最近业务中一个比较复杂表单，使用的是ElementUI，记录下表单的使用和遇到的问题

&lt;h2 id=&quot;1基本使用&quot;&gt;1.基本使用&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;el-form&amp;gt;
    &amp;lt;el-form-item&amp;gt;
    &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
在el-form标签内部可以嵌套其他标签
</description>
        <pubDate>Wed, 14 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/14/web-vue-elui-form/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/14/web-vue-elui-form/</guid>
        
        <category>vue</category>
        
        <category>elementui</category>
        
        
        <category>Web</category>
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>数字签名</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#概念&quot; id=&quot;markdown-toc-概念&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
数字签名又名公钥数字签名，基于非对称加密算法和数字摘要算法，具有三大特性：可认证性(authentication)、不可抵赖性(non-repudiation)和完整性(integrity)。

首先我们考虑一个场景，客户端B在访问一个域名服务器S时要解决几个问题
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;保证数据的安全，不被窃听&lt;/li&gt;
    &lt;li&gt;保证数据的完整，不被篡改&lt;/li&gt;
    &lt;li&gt;保证服务器是合法的，可认证的&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 14 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/14/criptogram-digital/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/14/criptogram-digital/</guid>
        
        <category>digital</category>
        
        
        <category>加密算法</category>
        
      </item>
    
      <item>
        <title>常见加密算法</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#对称加密算法&quot; id=&quot;markdown-toc-对称加密算法&quot;&gt;对称加密算法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#des&quot; id=&quot;markdown-toc-des&quot;&gt;DES&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
在网络通信中，信息加密是最基本的信息安全策略

&lt;h2 id=&quot;对称加密算法&quot;&gt;对称加密算法&lt;/h2&gt;
其特点是加密和解密使用相同的密钥

&lt;h3 id=&quot;des&quot;&gt;DES&lt;/h3&gt;
DES : Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。

有个升级版本DES3，相当于进行3次数据加密。其安全性能不高，在我们的业务中很少使用。
</description>
        <pubDate>Mon, 12 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/12/criptogram/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/12/criptogram/</guid>
        
        
        <category>加密算法</category>
        
      </item>
    
      <item>
        <title>Juni和EasyMock的使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
自动化测试工具

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;a href=&quot;https://blog.csdn.net/qq_41357569/article/details/85089818&quot;&gt;Juni和EasyMock配合使用&lt;/a&gt;
</description>
        <pubDate>Sat, 10 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/10/test-tool/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/10/test-tool/</guid>
        
        <category>jUnit</category>
        
        <category>easyMock</category>
        
        <category>maven</category>
        
        
        <category>自动化测试</category>
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>jemalloc介绍</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jemalloc基本信息&quot; id=&quot;markdown-toc-jemalloc基本信息&quot;&gt;jemalloc基本信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jemalloc基本信息&quot;&gt;jemalloc基本信息&lt;/h2&gt;

在学习Netty时，发现buffer引入缓冲池，其借用了jemalloc的思想；jemalloc在android5.1开始，成为libc默认的heap管理器。在这里搜索下jemalloc相关资料，以作记录。

jemalloc使用一系列算法保证程序在申请和释放内存的高效稳定，主要有以下几个特点：

&lt;ol&gt;
  &lt;li&gt;
    线程默认都有自己的私有缓存空间tcache，线程中分配内存都走这里，若未分配成功再走其他流程，线程内部的缓存空间中申请内存可以不加锁。
  &lt;/li&gt;
  &lt;li&gt;
    内存区重新规划，使用不同大小的分配单元
  &lt;/li&gt;
  &lt;li&gt;
    内存释放时，小内存合并为大内存，并判断是否需要缓存以供后续使用
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 09 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/09/jemalloc-use/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/09/jemalloc-use/</guid>
        
        <category>netty</category>
        
        
        <category>c/c++</category>
        
        <category>优化</category>
        
      </item>
    
      <item>
        <title>Netty框架</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
在讨论Netty之前需要了解下我们处理网络请求的方案

&lt;ol&gt;
  &lt;li&gt;
    BIO
同步阻塞，服务器调用accept阻塞等待请求，当请求到来时创建线程处理，主线程继续等待请求。
  &lt;/li&gt;
  &lt;li&gt;
    NIO
异步非阻塞，ServerSocketChannel非阻塞模式，使用selector轮询各类事件。
  &lt;/li&gt;
  &lt;li&gt;
    AIO
只需要关心buffer的读写事件
  &lt;/li&gt;
&lt;/ol&gt;

上述方案使用原生API直接开发，流程比较繁琐，性能不好，并且容易出错，使用Netty可以简化流程，Netty中使用Handler串行执行，结构层次分明，逻辑清晰，并且一个客户端只注册在一个线程上，避免部分业务中出现并发问题。
</description>
        <pubDate>Thu, 08 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/08/netty-use/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/08/netty-use/</guid>
        
        <category>netty</category>
        
        <category>socket</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java线程相关</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#锁&quot; id=&quot;markdown-toc-锁&quot;&gt;锁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;锁&quot;&gt;锁&lt;/h2&gt;

java中锁的实现分为两种：一种是synchronized关键字，一种是AbstractQueuedSynchronizer类，锁的核心就是如何管理竞争资源的线程。

当然根据实际的锁的业务类型，分为如下几类。

&lt;ol&gt;
  &lt;li&gt;
    偏向锁/轻量级锁/重量级锁
是指synchronized锁状态，描述在对象头部Mark Word（可以使用库jol-core，ClassLayout.parseInstance()方法查看）
  &lt;/li&gt;
  &lt;li&gt;
    可重入锁/非可重入锁
可重入锁代表ReentrantLock，reentrant意思是‘再次进入’
  &lt;/li&gt;
  &lt;li&gt;
    共享锁/独占锁
ReadWritLock
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 02 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4001/2021/07/02/java-thread/</link>
        <guid isPermaLink="true">http://localhost:4001/2021/07/02/java-thread/</guid>
        
        <category>thread</category>
        
        <category>threadlock</category>
        
        
        <category>java</category>
        
      </item>
    
  </channel>
</rss>
