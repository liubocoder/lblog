#常见算法

##排序算法

选择排序
标记左侧第一个位置，从标记位开始遍历选择最小数与标记位置交换，交换后，标记向后移一位，循环执行上述操作直到遍历完成。
时间复杂度：平均O(n²) 最好O(n²) 最坏O(n²)； 空间复杂度：O(1) 稳定性：稳定

插入排序
标记从第二元素开始，从标记位依次向左遍历，直到找到一个元素不比标记位大，将标记元素插入到该元素位置的右侧，标记向后移动一位，循环执行上述操作直到遍历完成。
时间复杂度：平均O(n²) 最好O(n) 最坏O(n²)； 空间复杂度：O(1) 稳定性：稳定

冒泡排序（优化）
目标是将最大的元素移动到最后，标记从0开始，与下一个元素比较，大于则交换，标记后移一位，依次遍历，遍历的截止长度为数组长度-遍历次数。
优化版本：当某次遍历时不存在元素交换，那么该数字已排序完成，可跳出循环
时间复杂度：平均O(n²) 最好O(n) 最坏O(n²)； 空间复杂度：O(1) 稳定性：稳定

希尔排序
在插入排序基础上优化，选取间隔为数组长度/2的元素，组成新的数组再次进行希尔排序，直到选取的间隔为1
时间复杂度：平均O(nlog n) 最好O(nlog² n) 最坏O(nlog² n)； 空间复杂度：O(1) 稳定性：不稳定

快速排序
选取一个元素，定义为中轴元素，将小于该元素的节点放置在其左侧，不小于该元素的节点放置在其右侧，然后再次将左右两侧的子数组进行快速排序，直到子数组的长度为1或0
时间复杂度：平均O(nlog n) 最好O(nlog n) 最坏O(n²)； 空间复杂度：O(log n) 稳定性：不稳定

归并排序
将数组一分为二，再次归并排序，直到子数组长度为1，长度为1的数组肯定是有序的，因此再对有序数组进行合并
时间复杂度：平均O(nlog n) 最好O(nlog n) 最坏O(nlog n)； 空间复杂度：O(n) 稳定性：稳定

堆排序
核心是将数组构建成二叉树，然后从根部开始删除元素实现排序
时间复杂度：平均O(nlog n) 最好O(nlog n) 最坏O(nlog n)； 空间复杂度：O(1) 稳定性：不稳定


计算排序：计数排序、桶排序、基数排序等
计算排序都使用到元素具体值进行计算，来得出计算值，根据算法再得到元素的值，个人感觉实用性不高。

##查找算法

顺序查找：适合存储方式是顺序或链表存储的线性表

二分查找：需要有序数组，二分查找还有一些优化版本，但是都需要基于有序数组，因此限制了其使用范围

树表查找
二叉树查找：需要构建二叉查找树
    特性：左子树的所有子节点都小于其根节点
        右子树的所有子节点都大于其根节点
    支持快速查找、插入、删除数据
    [算法参考](https://zhuanlan.zhihu.com/p/108653944)

红黑树：特殊的二叉查找树，也是接近平衡二叉树，节点还保存有颜色属性（红色或黑色）
    在执行插入、删除时通过算法保持红黑树特性，保证高效性
    红黑树有五个特性：
    1. 每个节点非黑即红
    2. 根节点为黑
    3. 每个叶子节点NULL 是黑色
    4. 一个红色节点的子节点必须是黑色
    5. 一个节点到该节点的子孙节点的所有路径上包含相同的黑节点数
    [参考资料](https://www.cnblogs.com/skywang12345/p/3245399.html)

#常见数据结构

##Array
数组

##List
单链表
循环链表
双链表
双向循环链表

##Map
HashMap

##Tree
二叉树
    满二叉树：所有节点有0或2个叶子节点
    完全二叉树：每层都是满的，最后一层不满则缺少右侧叶子节点
    完美二叉树：满二叉树基础上，所有叶子节点都在同一层
    平衡二叉树：空树或左右子树的高度差不超过1，子树也为平衡二叉树

四种遍历：
    前序遍历：先访问根节点，然后前序遍历左子树，再前序遍历右子树
    中序遍历：中序遍历根节点的左子树，然后是访问根节点，最后访问右子树
    后序遍历：从左到右叶子节点的方式遍历访问左右子树，最后访问根节点
    层序遍历：从根节点从上往下逐层遍历，在同一层，按从左到右的顺序逐个访问每个节点
递归实现上述遍历比较简单，复杂的是不使用递归的方式，则需要使用栈或队列的数据结构来完成。